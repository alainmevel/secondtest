/*2024-03-13T11:33:32-01:00*/

/********************************************************************
 * dcmotor.c
 * 
 * generated by: plcgen 3.1.391
 ********************************************************************/

#include "cb_comp.h"
#include "iec_1131.h"


/********************************************************************
 *                Inner 'stimuli_model' declarations                *
 ********************************************************************/


/********************** Variable declarations ***********************/

static CB_Index stimuli_model__num;
extern CB_Mem_Float *_i_dcmotor__stimuli_model_U;
extern CB_Mem_Float *_i_dcmotor__stimuli_model_M_load;

/********************** Function declarations ***********************/

static int _my_app__stimuli_model_init(void);
static int my_app__stimuli_model(void);

/********************************************************************
 *                     Inner 'sut' declarations                     *
 ********************************************************************/


/********************** Variable declarations ***********************/

static CB_Index sut__num;
extern CB_Mem_Float *_i_dcmotor__sut_M_load;
extern CB_Mem_Float *_i_dcmotor__sut_U;
extern CB_Mem_Float *_i_dcmotor__sut_I;
extern CB_Mem_Float *_i_dcmotor__sut_wB;
extern CB_Mem_Float *_i_dcmotor__sut_M_mot;
extern CB_Mem_Float *_i_dcmotor__sut_phiB;

/********************** Function declarations ***********************/

static int _my_app__sut_init(void);
static int my_app__sut(void);

/********************************************************************
 *               Inner 'emachine_model' declarations                *
 ********************************************************************/


/********************** Variable declarations ***********************/

static CB_Index emachine_model__num;
extern CB_Mem_Float *_i_dcmotor__emachine_model_phi;
extern CB_Mem_Float *_i_dcmotor__emachine_model_w;
extern CB_Mem_Float *_i_dcmotor__emachine_model_U;
extern CB_Mem_Float *_i_dcmotor__emachine_model_M;
extern CB_Mem_Float *_i_dcmotor__emachine_model_I;

/********************** Function declarations ***********************/

static int _my_app__emachine_model_init(void);
static int my_app__emachine_model(void);

/********************************************************************
 *                 Inner 'edrive_mass' declarations                 *
 ********************************************************************/


/********************** Variable declarations ***********************/

static CB_Index edrive_mass__num;
extern CB_Mem_Float *_i_dcmotor__edrive_mass_M_A;
extern CB_Mem_Float *_i_dcmotor__edrive_mass_M_B;
extern CB_Mem_Float *_i_dcmotor__edrive_mass_phiA;
extern CB_Mem_Float *_i_dcmotor__edrive_mass_wB;
extern CB_Mem_Float *_i_dcmotor__edrive_mass_wA;
extern CB_Mem_Float *_i_dcmotor__edrive_mass_phiB;

/********************** Function declarations ***********************/

static int _my_app__edrive_mass_init(void);
static int my_app__edrive_mass(void);

/********************************************************************
 *               Inner 'stimuli_model' implementation               *
 ********************************************************************/




/**************************** Variables *****************************/

static CB_Index stimuli_model__num = 0;
CB_Mem_Float *_i_dcmotor__stimuli_model_U;
CB_Mem_Float *_i_dcmotor__stimuli_model_M_load;

/**************************** Variables *****************************/

#define U (_i_dcmotor__stimuli_model_U->CB_current_value)
#define M_load (_i_dcmotor__stimuli_model_M_load->CB_current_value)


/************************ Components offsets ************************/


/********************* Initialization function **********************/

static int _my_app__stimuli_model_init(void)
{


	return 0;
}


/************************ Behavior function *************************/

static int my_app__stimuli_model(void)
{
	if (exec_term_node(self_num)) {

		/*********************** Internals variables ************************/


		/********************* Pre-conditions execution *********************/

		/*no Pre-conditions*/

		/************************ Behavior execution ************************/

		{

		}

		CB_post_float(_i_dcmotor__stimuli_model_U);
		CB_post_float(_i_dcmotor__stimuli_model_M_load);

		/******************** Post-conditions execution *********************/

		/*no Post-conditions*/
	}

	/*************************** self update ****************************/


	return 0;
}

#undef U
#undef M_load

/********************************************************************
 *                    Inner 'sut' implementation                    *
 ********************************************************************/



/**************************** Variables *****************************/

static CB_Index sut__num = 0;
CB_Mem_Float *_i_dcmotor__sut_M_load;
CB_Mem_Float *_i_dcmotor__sut_U;
CB_Mem_Float *_i_dcmotor__sut_I;
CB_Mem_Float *_i_dcmotor__sut_wB;
CB_Mem_Float *_i_dcmotor__sut_M_mot;
CB_Mem_Float *_i_dcmotor__sut_phiB;

/**************************** Variables *****************************/



/************************ Components offsets ************************/

static CB_Offset my_app__sut_offset_emachine_model;
static CB_Offset my_app__sut_offset_edrive_mass;
static CB_Offset my_app__sut_offset__end = {0, 0, 0, 0};


/********************* Initialization function **********************/

static int _my_app__sut_init(void)
{
	CB_Object __start = self;
	self.Float+=2;

	/*initialize child emachine_model (my_app.emachine_model):*/
	self_num++;
	my_app__sut_offset_emachine_model.Bool = self.Bool - __start.Bool;
	my_app__sut_offset_emachine_model.Int = self.Int - __start.Int;
	my_app__sut_offset_emachine_model.Float = self.Float - __start.Float;
	my_app__sut_offset_emachine_model.Char = self.Char - __start.Char;
	_i_dcmotor__emachine_model_phi = __start.Float+0; /*sut__cn_2*/
	_i_dcmotor__emachine_model_w = __start.Float+1; /*sut__cn_1*/
	_i_dcmotor__emachine_model_U = _i_dcmotor__sut_U;
	_i_dcmotor__emachine_model_M = _i_dcmotor__sut_M_mot;
	_i_dcmotor__emachine_model_I = _i_dcmotor__sut_I;
	_my_app__emachine_model_init();

	/*initialize child edrive_mass (my_app.edrive_mass):*/
	self_num++;
	my_app__sut_offset_edrive_mass.Bool = self.Bool - __start.Bool;
	my_app__sut_offset_edrive_mass.Int = self.Int - __start.Int;
	my_app__sut_offset_edrive_mass.Float = self.Float - __start.Float;
	my_app__sut_offset_edrive_mass.Char = self.Char - __start.Char;
	_i_dcmotor__edrive_mass_M_A = _i_dcmotor__sut_M_mot;
	_i_dcmotor__edrive_mass_M_B = _i_dcmotor__sut_M_load;
	_i_dcmotor__edrive_mass_phiA = __start.Float+0; /*sut__cn_2*/
	_i_dcmotor__edrive_mass_wB = _i_dcmotor__sut_wB;
	_i_dcmotor__edrive_mass_wA = __start.Float+1; /*sut__cn_1*/
	_i_dcmotor__edrive_mass_phiB = _i_dcmotor__sut_phiB;
	_my_app__edrive_mass_init();

	my_app__sut_offset__end.Bool = self.Bool - __start.Bool;
	my_app__sut_offset__end.Int = self.Int - __start.Int;
	my_app__sut_offset__end.Float = self.Float - __start.Float;
	my_app__sut_offset__end.Char = self.Char - __start.Char;

	return 0;
}


/************************ Behavior function *************************/

static int my_app__sut(void)
{
	CB_Object __start = self;
	int __ret;
	if (exec_mac_node(self_num)) {

		/*********************** Internals variables ************************/

				
		/********************* Pre-conditions execution *********************/

		/*no Pre-conditions*/

		/************************ Behavior execution ************************/

		{
			self.Bool = __start.Bool + my_app__sut_offset_emachine_model.Bool;
			self.Int = __start.Int + my_app__sut_offset_emachine_model.Int;
			self.Float = __start.Float + my_app__sut_offset_emachine_model.Float;
			self.Char = __start.Char + my_app__sut_offset_emachine_model.Char;

			/********************* emachine_model execution *********************/

			self_num++;
			if (emachine_model__num != self_num) {
				emachine_model__num = self_num;
				_i_dcmotor__emachine_model_phi = __start.Float+0; /*sut__cn_2*/
				_i_dcmotor__emachine_model_w = __start.Float+1; /*sut__cn_1*/
				_i_dcmotor__emachine_model_U = _i_dcmotor__sut_U;
				_i_dcmotor__emachine_model_M = _i_dcmotor__sut_M_mot;
				_i_dcmotor__emachine_model_I = _i_dcmotor__sut_I;
			}
			__ret = my_app__emachine_model();
			if (__ret != 0) {
				return __ret; /*child execution failure*/
			}

			/********************** edrive_mass execution ***********************/

			self_num++;
			if (edrive_mass__num != self_num) {
				edrive_mass__num = self_num;
				_i_dcmotor__edrive_mass_M_A = _i_dcmotor__sut_M_mot;
				_i_dcmotor__edrive_mass_M_B = _i_dcmotor__sut_M_load;
				_i_dcmotor__edrive_mass_phiA = __start.Float+0; /*sut__cn_2*/
				_i_dcmotor__edrive_mass_wB = _i_dcmotor__sut_wB;
				_i_dcmotor__edrive_mass_wA = __start.Float+1; /*sut__cn_1*/
				_i_dcmotor__edrive_mass_phiB = _i_dcmotor__sut_phiB;
			}
			__ret = my_app__edrive_mass();
			if (__ret != 0) {
				return __ret; /*child execution failure*/
			}

		}


		/******************** Post-conditions execution *********************/

		/*no Post-conditions*/
	}

	/*************************** self update ****************************/

	self.Bool = __start.Bool + my_app__sut_offset__end.Bool;
	self.Int = __start.Int + my_app__sut_offset__end.Int;
	self.Float = __start.Float + my_app__sut_offset__end.Float;
	self.Char = __start.Char + my_app__sut_offset__end.Char;

	return 0;
}


/********************************************************************
 *              Inner 'emachine_model' implementation               *
 ********************************************************************/




/**************************** Variables *****************************/

static CB_Index emachine_model__num = 0;
CB_Mem_Float *_i_dcmotor__emachine_model_phi;
CB_Mem_Float *_i_dcmotor__emachine_model_w;
CB_Mem_Float *_i_dcmotor__emachine_model_U;
CB_Mem_Float *_i_dcmotor__emachine_model_M;
CB_Mem_Float *_i_dcmotor__emachine_model_I;

/**************************** Variables *****************************/

#define phi (_i_dcmotor__emachine_model_phi->CB_current_value)
#define w (_i_dcmotor__emachine_model_w->CB_current_value)
#define U (_i_dcmotor__emachine_model_U->CB_current_value)
#define M (_i_dcmotor__emachine_model_M->CB_current_value)
#define I (_i_dcmotor__emachine_model_I->CB_current_value)


/************************ Components offsets ************************/


/********************* Initialization function **********************/

static int _my_app__emachine_model_init(void)
{


	return 0;
}


/************************ Behavior function *************************/

static int my_app__emachine_model(void)
{
	if (exec_term_node(self_num)) {

		/*********************** Internals variables ************************/


		/********************* Pre-conditions execution *********************/

		/*no Pre-conditions*/

		/************************ Behavior execution ************************/

		{

		}

		CB_post_float(_i_dcmotor__emachine_model_M);
		CB_post_float(_i_dcmotor__emachine_model_I);

		/******************** Post-conditions execution *********************/

		/*no Post-conditions*/
	}

	/*************************** self update ****************************/


	return 0;
}

#undef phi
#undef w
#undef U
#undef M
#undef I

/********************************************************************
 *                Inner 'edrive_mass' implementation                *
 ********************************************************************/




/**************************** Variables *****************************/

static CB_Index edrive_mass__num = 0;
CB_Mem_Float *_i_dcmotor__edrive_mass_M_A;
CB_Mem_Float *_i_dcmotor__edrive_mass_M_B;
CB_Mem_Float *_i_dcmotor__edrive_mass_phiA;
CB_Mem_Float *_i_dcmotor__edrive_mass_wB;
CB_Mem_Float *_i_dcmotor__edrive_mass_wA;
CB_Mem_Float *_i_dcmotor__edrive_mass_phiB;

/**************************** Variables *****************************/

#define M_A (_i_dcmotor__edrive_mass_M_A->CB_current_value)
#define M_B (_i_dcmotor__edrive_mass_M_B->CB_current_value)
#define phiA (_i_dcmotor__edrive_mass_phiA->CB_current_value)
#define wB (_i_dcmotor__edrive_mass_wB->CB_current_value)
#define wA (_i_dcmotor__edrive_mass_wA->CB_current_value)
#define phiB (_i_dcmotor__edrive_mass_phiB->CB_current_value)


/************************ Components offsets ************************/


/********************* Initialization function **********************/

static int _my_app__edrive_mass_init(void)
{


	return 0;
}


/************************ Behavior function *************************/

static int my_app__edrive_mass(void)
{
	if (exec_term_node(self_num)) {

		/*********************** Internals variables ************************/


		/********************* Pre-conditions execution *********************/

		/*no Pre-conditions*/

		/************************ Behavior execution ************************/

		{

		}

		CB_post_float(_i_dcmotor__edrive_mass_phiA);
		CB_post_float(_i_dcmotor__edrive_mass_wB);
		CB_post_float(_i_dcmotor__edrive_mass_wA);
		CB_post_float(_i_dcmotor__edrive_mass_phiB);

		/******************** Post-conditions execution *********************/

		/*no Post-conditions*/
	}

	/*************************** self update ****************************/


	return 0;
}

#undef M_A
#undef M_B
#undef phiA
#undef wB
#undef wA
#undef phiB

/********************************************************************
 *              Public 'my_app.dcmotor' implementation              *
 ********************************************************************/

#include "dcmotor.h"


/**************************** Variables *****************************/

CB_Index dcmotor__num = 0;
CB_Mem_Float *dcmotor_wB;
CB_Mem_Float *dcmotor_I;
CB_Mem_Float *dcmotor_U;
CB_Mem_Float *dcmotor_M_mot;

/**************************** Variables *****************************/



/************************ Components offsets ************************/

static CB_Offset my_app__dcmotor_offset_stimuli_model;
static CB_Offset my_app__dcmotor_offset_SuT;
static CB_Offset my_app__dcmotor_offset__end = {0, 0, 0, 0};


/********************* Initialization function **********************/

int _my_app__dcmotor_init(void)
{
	CB_Object __start = self;
	self.Float+=2;

	/*initialize child stimuli_model (my_app.stimuli_model):*/
	self_num++;
	my_app__dcmotor_offset_stimuli_model.Bool = self.Bool - __start.Bool;
	my_app__dcmotor_offset_stimuli_model.Int = self.Int - __start.Int;
	my_app__dcmotor_offset_stimuli_model.Float = self.Float - __start.Float;
	my_app__dcmotor_offset_stimuli_model.Char = self.Char - __start.Char;
	_i_dcmotor__stimuli_model_U = dcmotor_U;
	_i_dcmotor__stimuli_model_M_load = __start.Float+1; /*dcmotor__cn_1*/
	_my_app__stimuli_model_init();

	/*initialize child SuT (my_app.sut):*/
	self_num++;
	my_app__dcmotor_offset_SuT.Bool = self.Bool - __start.Bool;
	my_app__dcmotor_offset_SuT.Int = self.Int - __start.Int;
	my_app__dcmotor_offset_SuT.Float = self.Float - __start.Float;
	my_app__dcmotor_offset_SuT.Char = self.Char - __start.Char;
	_i_dcmotor__sut_M_load = __start.Float+1; /*dcmotor__cn_1*/
	_i_dcmotor__sut_U = dcmotor_U;
	_i_dcmotor__sut_I = dcmotor_I;
	_i_dcmotor__sut_wB = dcmotor_wB;
	_i_dcmotor__sut_M_mot = dcmotor_M_mot;
	_i_dcmotor__sut_phiB = __start.Float+0; /*dcmotor__cn_2*/
	_my_app__sut_init();

	my_app__dcmotor_offset__end.Bool = self.Bool - __start.Bool;
	my_app__dcmotor_offset__end.Int = self.Int - __start.Int;
	my_app__dcmotor_offset__end.Float = self.Float - __start.Float;
	my_app__dcmotor_offset__end.Char = self.Char - __start.Char;

	return 0;
}


/************************ Behavior function *************************/

int my_app__dcmotor(void)
{
	CB_Object __start = self;
	int __ret;
	if (exec_mac_node(self_num)) {

		/*********************** Internals variables ************************/

				
		/********************* Pre-conditions execution *********************/

		/*no Pre-conditions*/

		/************************ Behavior execution ************************/

		{
			self.Bool = __start.Bool + my_app__dcmotor_offset_stimuli_model.Bool;
			self.Int = __start.Int + my_app__dcmotor_offset_stimuli_model.Int;
			self.Float = __start.Float + my_app__dcmotor_offset_stimuli_model.Float;
			self.Char = __start.Char + my_app__dcmotor_offset_stimuli_model.Char;

			/********************* stimuli_model execution **********************/

			self_num++;
			if (stimuli_model__num != self_num) {
				stimuli_model__num = self_num;
				_i_dcmotor__stimuli_model_U = dcmotor_U;
				_i_dcmotor__stimuli_model_M_load = __start.Float+1; /*dcmotor__cn_1*/
			}
			__ret = my_app__stimuli_model();
			if (__ret != 0) {
				return __ret; /*child execution failure*/
			}

			/************************** SuT execution ***************************/

			self_num++;
			if (sut__num != self_num) {
				sut__num = self_num;
				_i_dcmotor__sut_M_load = __start.Float+1; /*dcmotor__cn_1*/
				_i_dcmotor__sut_U = dcmotor_U;
				_i_dcmotor__sut_I = dcmotor_I;
				_i_dcmotor__sut_wB = dcmotor_wB;
				_i_dcmotor__sut_M_mot = dcmotor_M_mot;
				_i_dcmotor__sut_phiB = __start.Float+0; /*dcmotor__cn_2*/
			}
			__ret = my_app__sut();
			if (__ret != 0) {
				return __ret; /*child execution failure*/
			}

		}


		/******************** Post-conditions execution *********************/

		/*no Post-conditions*/
	}

	/*************************** self update ****************************/

	self.Bool = __start.Bool + my_app__dcmotor_offset__end.Bool;
	self.Int = __start.Int + my_app__dcmotor_offset__end.Int;
	self.Float = __start.Float + my_app__dcmotor_offset__end.Float;
	self.Char = __start.Char + my_app__dcmotor_offset__end.Char;

	return 0;
}

